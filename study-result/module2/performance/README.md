### js 垃圾回收引用回收
- 引用对象表示从全局作用域下可以被找到的变量，就是可达的对象，使用的次数表示引用次数，依次累加，
```js
let a = {};
// a的次数设置为 null 但是依然被引用
let c = [a];
a = null;
 ```
 ```js
 // 全局开始找就找到了有 P1 和 P2 对应的对象但是是通过 d 找到的，如果 delete d.p1 delete d.p2则 o1找不到就被清除掉，o2也找不到，这就是垃圾回收
 function bind(o1, o2) {
    o1.s = o1;
    o2.s = o1;
    return {
        p1: o1,
        p2: o2,
    }
 }
  bind({p:1}, {o:67})
 ```
 GC 就是垃圾回收器，主要查找垃圾释放空间
 - 引用计数
 缺点：无法处理循环引用、时间消耗大，引用计数器资源消耗大
 优点：响应速度快，时刻监控，释放内存，及时回收垃圾
 ```js
 function ex() {
    let a = {}
    let s = {};
    // 即使函数执行结束全局找不到，删除的时候发现互相引用，所以无法释放，但是如果使用标记清除但是在全局找不到则标记为0进行清除
    a.n = s;
    s.f = a;
    return '890'
 }
 ````
 - 标记清除
 从根开始递归标记进行可达标记记录，清除标记为0的清除后，标记也清0
 主要是先标记，然后清除
  缺点：空间碎片化，清除的垃圾不连续，清除和不清楚的合成碎片化空间，响应速度慢，响应速度慢递归标记所有对象，GC执行时程序停止工作
  优点：解决循环引用
 - 标记整理
  缺点：清除的垃圾变成连续位置，清除就没有内存的碎片化，响应速度慢递归标记所有对象，GC执行时程序停止工作
  优点：解决循环引用
 - V8垃圾回收：分代回收和标记增量
 新生代空间存放存活时间较短的变量，回收采用复制算法+标记整理
  缺点：无法处理循环引用
  优点：响应速度快

  ### V8即时编译、针对浏览器所以内存有上限
  ### 内存问题（网络问题正常）：页面延迟加载或经常性暂停有可能频繁的垃圾回收又上到下持续执行而不是到达平稳，页面持续性的出现糟糕的性能，界面流畅度随时间性能越来越差有可能内存泄漏
  ### 内存监控
  - 垃圾回收：频繁的垃圾回收，通过内存变化图分析
  - 内存泄漏：内存持续升高在 performance 内存线中，不会下降
  - 内存膨胀：在多数设备上运行程序都是性能一致差劲来判定代码是否内存膨胀
  ### 监控内存方式
  - 浏览器任务管理器 重点看 内存 + javascript 内存表示可达对象使用的内存
  - timeline 时序图
  - 堆快照查找分离 DOM 也是一种内存泄漏
  - 判断是否存在频繁的垃圾回收
  ### 查看是否频繁垃圾回收
  查看曲线从上到下从上到下一直保持如此
  ### 代码优化
  - 缓存全局变量
  - for 循环就是缓存 length 保证每次不再读取 length
  - 在对象原型上添加方法和属性效率更好
  - 闭包使用后需要释放，闭包指的是外部引用内部的作用域
  - 不要通过访问方法来返回属性，效率低，所以考虑这么写需要思考一下取舍
  - forEach > for > for in
  - 文档碎片节点操作，使用documentFragment进行创建节点后添加子节点最后documentFragment添加到document下面
  - 克隆节点使用 cloneNode 就不需要在进行属性和样式的重新赋给，达到节约性能的效果
  - 字面量比 new 对象的方式性能更好
  ```
  // 字面量效果更好
  let a = [1, 2]
  // 性能差一点
  let b = new Array()
  b[0] = 1;
  b[1] = 2;
  ```
  - 减少作用域链的变量查找层级，但是也要考虑变量开辟内存的大小
  - 每个函数执行都有对应执行上下文
  performance 中异常
  - 频繁的上升下降
  - 任务管理器中数据频繁的增加减少就是在GC和内存泄漏过程
  为什么我们要重视内存泄漏
  - GC工作时应用程序是停止的
  - 频繁且过长的 GC 会导致应用假死
  - 用户使用中感知应用卡顿
  内存泄漏的来源
  - 游离dom不会被内存回收使用快照进行确定
  - 泄漏的堆内存