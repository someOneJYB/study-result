// map 对比 object 就是 key 为任意值，但是 object 只能是 string
// weakmap 和 map 的区别主要是 weakmap 的 key 只能是 object null 除外，而且应用的 key 被 GC 掉就会自动删除对应的 value，WeakMap  不能包含无引用的对象，否则会被自动清除出集合（垃圾回收机制）；
// WeakMap  对象没有 size 属性，是不可枚举的，无法获取集合的大小。
// WeakSet  结构与 Set 类似，也是不重复的值的集合。
// 在 JavaScript 中，原始类型的数据被分配到栈空间中，引用类型的数据会被分配到堆空间中。
// 栈空间中的垃圾回收：当定义一个函数被执行结束以后定义的变量运行上下文中不再 被引用的变量就会被销毁
// 堆空间中的垃圾回收：堆中数据垃圾回收策略的基础是：代际假说（The Generational Hypothesis）。即：
//
// 大部分对象在内存中存在时间极短，很多对象很快就不可访问。不死的对象将活得更久。
// 这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。
// V8 引擎将堆空间分为新生代（存放生存时间短的对象）比较小和老生代（存放生存时间长的对象）比较大两个区域，并使用不同的垃圾回收器。
// 新生代对象空间分为 from 和 to 存活时间短（局部作用域中变量）使用复制算法+标记整理，新生代内存分为两个等大小空间，使用空间 from，空闲为 to，活动对象存储于 from 空间标记整理后活动对象到 to，二者空间交换， 清除 to
// 老生代对象（存活时间较长对象全局和闭包等）回收：标记清除 + 标记整理 + 增量标记，主要采用标记清除完成垃圾回收，新生代往老生代移动对象的时候需要老生代标记整理获得空间的使用
// 在新生代回收中：对象可能会移动到老生代，一轮GC后的对象移动到老生代，
// 副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。
// 垃圾回收流程：标记活动对象和非活动对象，回收非活动对象的内存，最后内存整理。
// 副垃圾回收：新生区使用空间换时间因为区域太小和老生区，新生区有对象区域和空闲区域
// 增量标记实现原理：遍历对象标记可达对象时候会导致程序无法执行，但是分块，执行程序的时候和进行遍历是分块的，在程序完成垃圾回收之后程序继续，
// - 执行流程：
// 新对象存在在对象区域，当对象区域将要写满时，执行一次垃圾回收；
// 垃圾回收过程中，首先对对象区域中的垃圾做标记，
// 副垃圾回收器： 将存活的对象复制并有序排列到空闲区域，相当于完成内存整理。
// 复制完成后，将对象区域和空闲区域翻转，完成垃圾回收操作，这也让新生代中两块区域无限重复使用。

// 若复制操作的数据较大则影响清理效率。
// JavaScript 引擎的解决方式是：将新生代区域设置得比较小，并采用对象晋升策略（经过两次回收仍存活的对象，会被移动到老生区），避免因为新生代区域较小引起存活对象装满整个区域的问题。
// 主垃圾回收器：标记删除法，标记 - 清除（Mark-Sweep）算法，和标记 - 整理（Mark-Compact）算法。
// 标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；
// 清除过程：清理被标记的数据，并产生大量碎片内存。（缺点：导致大对象无法分配到足够的连续内存）
// 标记 - 整理（Mark-Compact）算法
// 标记过程：从一组根元素开始遍历整个元素，能到达的元素为活动对象，反之为垃圾数据；
// 整理过程：将所有存活的对象，向一端移动，然后清除端边界以外的内容
// 就是 weakmap 和 weakset 中的key或者值被回收掉，那么对应的 value 就没有了
let a = new WeakMap()

let f = {a: 7}

a.set(a, 45)
// WeakMap {WeakMap => 45}
// 回收之后就会发现对应的 value 消失了
f = null
// WeakMap
// ƒ WeakMap() { [native code] }